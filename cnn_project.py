# -*- coding: utf-8 -*-
"""CNN project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HKC5oW54RVw5JYfgb2dkCBvzhCxtYpBi
"""

#importing the necessary modules
from keras.datasets import mnist
import numpy as np


#loading data
(xtrain,ytrain),(xtest,ytest)=mnist.load_data()

#What mnist images look like
import matplotlib.pyplot as plt
print("Training data:")
plt.imshow(xtrain[4])
plt.show()
print("Label of this image is",ytrain[4])

#reshaping data as needed by the model
xtrain=np.reshape(xtrain,(-1,28,28,1))
xtest=np.reshape(xtest,(-1,28,28,1))
xtrain.shape,xtest.shape,ytrain.shape,ytest.shape

#normalising
xtrain=xtrain/255
xtest=xtest/255

#implementing one hot encoding
from keras.utils import to_categorical # importing to_categorical from keras.utils

#importing the model
from keras.models import Sequential

y_train = to_categorical(ytrain, num_classes=10)
y_test = to_categorical(ytest, num_classes=10)


#creating model object
model=Sequential()


#importing layers
from keras.layers import Conv2D,MaxPooling2D,Flatten,Dense,Dropout


#adding layers and forming the model
model.add(Conv2D(32,kernel_size=5,strides=1,padding="Same",activation="relu",input_shape=(28,28,1)))
model.add(MaxPooling2D(padding="same"))

model.add(Conv2D(64,kernel_size=5,strides=1,padding="same",activation="relu"))
model.add(MaxPooling2D(padding="same"))

model.add(Flatten())

model.add(Dense(1024,activation="relu"))
model.add(Dropout(0.2))
model.add(Dense(10,activation="sigmoid"))

#compiling
model.compile(optimizer="adam",loss="categorical_crossentropy",metrics=["accuracy"])

#training the model
model.fit(xtrain,y_train,batch_size=100,epochs=5,validation_data=(xtest,y_test))

# evaluate
loss, accuracy = model.evaluate(xtest, y_test)

model.save('handwrittendigit.keras')

# libraries
import os
import cv2
import numpy as np
import tensorflow as tf
from PIL import Image
import tempfile

# Corrected function to classify the image
def classify_digit(model, image):
    img = cv2.imread(image, cv2.IMREAD_GRAYSCALE)  # Read the image in grayscale
    # Resize the image to 28x28 pixels
    img = cv2.resize(img, (28, 28))
    img = np.array(img)  # Convert to a numpy array
    img = img.reshape(1, 28, 28, 1)  # Reshape to match the model's input shape
    img = img.astype('float32') / 255.0  # Normalize to range [0, 1]
    prediction = model.predict(img)
    return prediction

# Function to resize the image (for display purposes)
def resize_image(image, target_size):
    resized_image = image.resize(target_size)
    return resized_image

 # Display the resized image using matplotlib (install matplotlib if you haven't already)
    import matplotlib.pyplot as plt
    plt.imshow(resized_image, cmap='gray')
    plt.show()

    # Load the pre-trained model
    model = tf.keras.models.load_model('handwrittendigit.keras')

    # Classify the new image
    prediction = classify_digit(model, temp_image_path)

    # Print the prediction result
    print(f'The digit is probably a {np.argmax(prediction)}')

    os.remove(temp_image_path)